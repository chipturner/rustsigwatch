# CLAUDE.md

This file was auto-generated by Claude Code to provide future instances with context about this codebase.

## Project Overview

RustSigWatch is a high-performance BPF-based system monitoring tool that tracks signals, process creation, and termination events in real-time. It uses the aya-rs BPF framework to hook into kernel tracepoints and provide low-overhead monitoring capabilities.

## Development Commands

Common development commands from justfile:

```bash
# Development build
just dev

# Optimized release build  
just build

# Run all checks (format + lint + test)
just check

# Format code
just fmt

# Run clippy linter
just clippy

# Run tests
just test

# Manual BPF compilation (debugging)
just bpf

# Clean build artifacts
just clean

# Run the tool (requires sudo)
just run

# Show dependency installation help
just install-deps
```

## High-Level Architecture

The architecture follows a kernel-to-userspace BPF monitoring pattern:

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Kernel Space  │    │   BPF Programs   │    │   User Space    │
│                 │    │                  │    │                 │
│ Signal Syscalls ├───►│ Tracepoint Hooks ├───►│ rustsigwatch    │
│ Process Events  │    │ Event Collection │    │ Event Display   │
│                 │    │ Ring Buffer      │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

### Key Components

1. **BPF Programs** (`src/bpf/sigwatch.bpf.c`):
   - Hooks syscall tracepoints: `sys_enter_kill`, `sys_enter_tkill`, `sys_enter_tgkill`
   - Hooks scheduler tracepoints: `sched_process_fork`, `sched_process_exit`
   - Uses ring buffer for efficient kernel-to-userspace event transport
   - Critical implementation detail: manual syscall argument parsing with `bpf_probe_read`

2. **Userspace Application** (`src/main.rs`):
   - Loads BPF programs using aya framework
   - Processes events from ring buffer
   - Formats and displays signal/process information with timestamps

3. **Signal Processing** (`src/signals.rs`):
   - Signal name resolution (number ↔ symbolic name)
   - Signal filtering logic for targeted monitoring
   - Supports both numeric (9, 15) and symbolic (SIGKILL, SIGTERM) signal names

## Important Technical Notes

### BPF Syscall Argument Parsing
The tool uses manual argument parsing for syscall tracepoints due to reliability issues with BPF_PROG macro:

```c
// Critical: Direct memory access at fixed offsets
bpf_probe_read(&pid, sizeof(pid), (char *)ctx + 16); // args[0]
bpf_probe_read(&sig, sizeof(sig), (char *)ctx + 24); // args[1]
```

### Signal Filtering
- Filters out signal 0 (non-real signals) in BPF to reduce noise
- Signal number validation ensures proper name resolution
- Default monitoring: SIGTERM (15), with options for specific signals or all signals

### Dependencies
- **Build Requirements**: clang, libbpf-dev, linux-headers
- **Runtime Requirements**: Linux kernel 5.5+, root privileges for BPF loading
- **Rust Framework**: aya 0.12 for BPF integration

## Project Structure

```
src/
├── main.rs              # Main application entry point
├── lib.rs               # Library interface
├── signals.rs           # Signal parsing and filtering
├── bpf/
│   ├── mod.rs           # BPF userspace integration
│   └── sigwatch.bpf.c   # BPF kernel programs
├── Cargo.toml           # Dependencies and build config
├── build.rs             # BPF compilation script
└── Makefile             # Development workflow automation
```

## Key Design Decisions

1. **aya-rs over libbpf-sys**: Better Rust integration and memory safety
2. **Ring buffer over perf events**: Lower latency and better performance
3. **Manual syscall parsing**: Reliable argument extraction across kernel versions
4. **In-kernel filtering**: Reduces userspace processing overhead
5. **Tracepoint-based**: More stable than kprobes across kernel updates

## Common Issues

1. **Permission denied**: Tool requires sudo for BPF program loading
2. **Missing clang**: Install development dependencies via `make install-deps`
3. **Signal shows "UNKNOWN"**: Usually indicates BPF argument parsing issues
4. **Large signal numbers**: Suggests incorrect memory offset in bpf_probe_read

## Testing

Run the complete test suite with:
```bash
make check  # Runs fmt + clippy + test
```

The tool includes unit tests for signal parsing and filtering logic in `src/signals.rs`.